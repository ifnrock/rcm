Алгоритм выработки рекомендаций состоит из двух частей. Первая часть парсирует access.log веб-сервера и формирует user profiles. Вторая часть на основе построенных user profiles считает рекомендацию.

Предварительная часть алгоритма.

Исходным источником информации является access.log веб-сервера, логирующий обращения к сайту в строках следующего вида (nginx, combined format):
'192.33.5.1 - - [21/Apr/2013:23:16:10 +0400] "GET /some_page.html HTTP/1.1" 200 498 "-" "-"'.
Лог должен быть распарсен до получения пар <ip, url> для каждого удачного (status code 200) GET-запроса. Каждая такая пара соответствует факту запроса ресурса с определённого ip.

Включать POST-запросы в выборку вряд ли стоит: хотя доступ к некоторым ресурсам может требовать авторизации например, собственно пост пользовательских данных будет идти отдельно от запроса ресурса, и выражен тот будет через GET. Возможно для большей реалистичности стоит включать запросы типа 403 Forbidden или 401 Not Authorized - это также характеризует интересы пользователей.

При запросе какой-либо страницы браузер как правило тянет массу статики: css, js, картинки, флеш и т.п. Это "шум", он ничего не говорит о предпочтениях пользователей, и его нужно отфильтровывать.

Access.log веб-сервера Apache мне не знаком и не рассматривается, но и пользоваться им нынче вроде перестали.

Отметим, что nginx используется для проксирования запросов. Выполняются они в контейнерах приложений, которые имеют собственные гораздо более информативные логи. Они нас не интересуют.

Итого, на первом шаге для каждого ip мы должны получить user session - булевский вектор запрошенных ресурсов.

Далее, полученное множество user sessions необходимо кластеризовать. Каждый кластер должен соответствовать некоторому "паттерну поведения" пользователей. "Паттерн поведения" в нашем случае будет группировать ресурсы сервера и позволит строить простые суждения типа: "Если человек посетил страничку X.html, то он возможно посетит и страничку Y.html, ведь так сделали остальные посетители странички X.html". Алгоритмов кластеризации существует довольно много, и для простоты был выбран k-means с евклидовым расстоянием в качестве меры близости векторов.

Следовательно, на втором шаге user sessions кластеризуются.

Каждому полученному кластеру следует сопоставить user profile - определённый на схеме вектор частот появления каждого ресурса в кластере. User profile позволяет судить об относительной заинтересованности в ресурсах для человека, чьё поведение удовлетворяет этому паттерну.

Посчитанные user profiles составляют результат предварительной части алгоритма выработки рекомендаций, и должны быть сохранены в базе данных для последующего использования.

